\documentclass{article}
\usepackage[a4paper,scale=0.8,hcentering,bindingoffset=8mm]{geometry} % A4纸大小，缩放80%，设置奇数页右边留空多一点
\usepackage{hyperref}      % 超链接
\usepackage{listings}      % 代码块
\usepackage{courier}       % 字体
\usepackage{fontspec}      % 字体
\usepackage{fancyhdr}      % 页眉页脚相关宏包
\usepackage{lastpage}      % 引用最后一页
\usepackage{amsmath,amsthm,amsfonts,amssymb,bm} %数学
\usepackage{graphicx}      % 图片
\usepackage{subcaption}    % 图片描述
\usepackage{longtable,booktabs} % 表格
\usepackage{ctex}
\usepackage{soul}
\usepackage{hyperref}
\lstset{                  %设置代码块
         basicstyle=\footnotesize\ttfamily,% 基本风格
         numbers=left,    % 行号
         numbersep=10pt,  % 行号间隔 
         tabsize=4,       % 缩进
         extendedchars=true, % 扩展符号？
         breaklines=true, % 自动换行
         language=C,
         frame=leftline,  % 框架左边竖线
         xleftmargin=5pt,% 竖线左边间距
         showspaces=false,% 空格字符加下划线
         showstringspaces=false,% 字符串中的空格加下划线
         showtabs=false,  % 字符串中的tab加下划线
 }
\pagestyle{fancy}         % 页眉页脚风格
\fancyhf{}                % 清空当前设置
\fancyfoot[C]{\thepage\ / \pageref{LastPage}}%页脚中间显示 当前页 / 总页数，把\label{LastPage}放在最后
\begin{document} 
    \begin{titlepage}       % 封面
        \centering
        \includegraphics[width=\textwidth]{../SUSTC_LOGO.png}
        % \vspace*{\baselineskip}
        \rule{\textwidth}{1.6pt}\vspace*{-\baselineskip}\vspace*{2pt}
        \rule{\textwidth}{0.4pt}\\[\baselineskip]
        {\LARGE COMPILIER @Liu Yepang 2019\\[\baselineskip]\small for SUSTech CSE}
        \\[0.2\baselineskip]
        \rule{\textwidth}{0.4pt}\vspace*{-\baselineskip}\vspace{3.2pt}
        \rule{\textwidth}{1.6pt}\\[\baselineskip]
        \scshape
        \vspace*{\baselineskip}
        {\Large Project 2\par }
        Edited by \\[\baselineskip] {汪至圆\par}
        {\Large 11610634\par }
        \vfill
        {\scshape 2019} \\{\large SHENZHEN}\par
    \end{titlepage}

    \section{Lab Demand}
        In last project, I have finished the parser for the SPL source code and generated the syntex 
        tree. In this project, I will do the semantic analysis for the SPL source code based on the syntex 
        generated by the last project.
        

    \section{Environment}
        The environment for my project is g++ 9.1, flex 2.6, bison 3.4. All the work of coding
        and test was finished in the Manjaro 18.1 which based on Linux 4.19.
    \section{Run}
        My project was compiled by the make. If you want to compile the project, you just need run `\hl{make splc}'. 
        And then it will output a executable file splc.out. The splc.out will receive a argument which is the path of 
        SPL source code file, and the output of the program will at the same folder of the source code and the extend name of the file 
        will be ".out". The context of the output file will be the error in the source code file.

    \section{Data Structures To Store Message} 
        To store the message of the variable, function, scope and the structure, I design some data structure.
        \begin{itemize}
            \item Variable Information:
\begin{lstlisting}
struct VarInfo {
    string name; //Variable name
    int type; //Variable type
    bool array; //If the Variable is array
    int dimension; //The dimension of the Variable
};
\end{lstlisting}
            \item Function Information:
\begin{lstlisting}
struct FuncInfo {
    string name; //Function name
    int returnType; //Return Type of the Function
    vector<VarInfo> argSet; //The arguments of the Function
};
\end{lstlisting}  
            \item Structure Information:
\begin{lstlisting}
struct StructInfo {
    string name; //The name of the Structure
    vector<VarInfo> varSet; //The fields of the Structure
};    
\end{lstlisting}
            \item Scopes Information:
\begin{lstlisting}
struct ScopeInfo {
    map<string, VarInfo> varSet; //The variables in current scope.
    ScopeInfo *parentScope = nullptr; // The parent Scope of current scope.
    vector<ScopeInfo> childList; //The children Scopes of current scope.
};
\end{lstlisting}
        \end{itemize}
    \section{Definition Process}
        All the variable, function, structure must be defined before use it. When define the variable, I will check if the type of it exists,
        and whether the variable name exists in the current scope. When define the function, I will check the return type and the arguments type exists or not.
        And the function name exists or not. The SPL not support overload the function now. When define the structure, I will check the structure name haven't been defined, and the 
        types of the fields is existed.

    \section{Executing Process}
        After definition, there are also some executing codes. For these codes, I will check the types of the expressions next the operators, 
        the return type of the function, the existence of the variables, functions and structures. 
    \section{Optional Rules}
        For the two optional rules, I implement all of them.

        For the first optional rules, I define a global scope tree, the root of the tree is at the root of the syntex tree, 
        while define a new function or create a new If/While statement, I will create a new scope as a child scope of current scope.
        While define the variable, I will only check the current scope, but when finding a variable which is defined, I will find it in the scope tree recursively until find it or arrive the root scope.

        For the second optional rules, I define the fields of the structure in a array, and when check the type of two variables, if they are strcuture, I will check the type of fields of them.

    \section{bonus}
        \subsection{Add a new type bool}
            Revoke Assumption 2, I add a new type bool, and set only bool type value can be used as the condition of the If/While statement.
        
            The test file is \hl{test/test\_2\_b01.spl}

        \subsection{Orderd structural equivalence}
            For the two strcuture, I will check their fields in order. For example:

            \begin{lstlisting}[]
struct a{
    int c; 
    float d
}
strcut b{
    float d; 
    int c
}
            \end{lstlisting}

                a and b are different.

                The test file is \hl{test/test\_2\_b02.spl}

        \subsection{Recursive structural equivalence}
            For two structures, if they have structure variables in their fields, I will check the fields recursively. For example:
            
            \begin{lstlisting}
struct a{
    int c;
    int d;
};
struct b{
    int c;
    int d;
};
struct a1{
    struct a aa;
    int i;
};

struct b1{
    struct b bb;
    int i;
};

struct a2{
    struct b1 bb;
    int i;
};
            \end{lstlisting}

            a1 and b1 are the same, a1 and a2 are different.

            The test file is \hl{test/test\_2\_b03.spl}
        \subsection{Assignment/Operation Between INT and FLOAT Variables}
            Revoke Assumption 1, when do operation between int and the float, the return value will be float. 
            And we can assign int value to float variable, but float value can't be assigned to int variable. 
            
            The test file is \hl{test/test\_2\_b04.spl}
\end{document}